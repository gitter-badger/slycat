<!DOCTYPE html>
<html>
<head>
	<style type="text/css">
    canvas, svg { border: 1px solid black !important; }
    .kinetic { display: inline-block; }
  </style>
	<script src="d3.v3.min.js" type="text/javascript"></script>
	<script src="kinetic-v5.1.0.min.js" type="text/javascript"></script>
	<script src="fabric.min.js" type="text/javascript"></script>
	<script type="text/javascript">
	//&lt;![CDATA[ 
	window.onload=function(){
	var base = d3.select("#vis");
	var width = 800,
		  height = 600
		  numberOfElements = 50000;

	var data = d3.range(numberOfElements)
		.map(function(currentValue, index, array){
			return {
				index: currentValue,
				x: Math.random() * (width-20) + 10,
				y: Math.random() * (height-20) + 10,
			};
		})
		;

	var circleChart = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var circleContext = circleChart.node().getContext("2d");
	circleContext.fillStyle = "orange";
	circleContext.strokeStyle = "black";
	circleContext.lineWidth = 1.5;

	var circleChartColors = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var circleContextColors = circleChartColors.node().getContext("2d");
	circleContextColors.fillStyle = "orange";
	circleContextColors.strokeStyle = "black";
	circleContextColors.lineWidth = 1.5;

	var squareChart = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var squareContext = squareChart.node().getContext("2d");
	squareContext.fillStyle = "orange";
	squareContext.strokeStyle = "black";
	squareContext.lineWidth = 1;

	var squareChartColors = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var squareContextColors = squareChartColors.node().getContext("2d");
	squareContextColors.fillStyle = "orange";
	squareContextColors.strokeStyle = "black";
	squareContextColors.lineWidth = 1;

	var circleOffscreenChart = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var circleOffscreenContext = circleOffscreenChart.node().getContext("2d");
	circleOffscreenContext.fillStyle = "orange";
	circleOffscreenContext.strokeStyle = "black";
	circleOffscreenContext.lineWidth = 1;

	var squareOffscreenChart = base.append("canvas")
	  .attr("width", width)
	  .attr("height", height);
	var squareOffscreenContext = squareOffscreenChart.node().getContext("2d");
	squareOffscreenContext.fillStyle = "orange";
	squareOffscreenContext.strokeStyle = "black";
	squareOffscreenContext.lineWidth = 1;

	var squareOffscreenCanvas = d3.select(document.createElement("canvas"))
	  .attr("width", width)
	  .attr("height", height);
	var squareOffscreenCanvasContext = squareOffscreenCanvas.node().getContext("2d");
	squareOffscreenCanvasContext.fillStyle = "orange";
	squareOffscreenCanvasContext.strokeStyle = "black";
	squareOffscreenCanvasContext.lineWidth = 1;

	var start = performance.now();
	drawCircles(circleContext);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " circle elements: " + (end-start) + " milliseconds.");

	var start = performance.now();
	drawCirclesColors(circleContextColors);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " colored circle elements: " + (end-start) + " milliseconds.");

	var start = performance.now();
	drawSquares(squareContext);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " square elements: " + (end-start) + " milliseconds.");

	var start = performance.now();
	drawSquaresColors(squareContextColors);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " colored square elements: " + (end-start) + " milliseconds.");

	var start = performance.now();
	drawSquaresColors(squareOffscreenCanvasContext);
	squareOffscreenContext.drawImage(squareOffscreenCanvas.node(), 0, 0);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " colored square offscreen elements: " + (end-start) + " milliseconds.");

	function drawCircles(context) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	  	context.beginPath();
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    //context.moveTo(cx, cy);
	    context.arc(cx, cy, 3, 0, 2 * Math.PI, false);
	    context.stroke();
	    context.fill();
	  }
	}

	function drawCirclesColors(context) {
		var color = d3.scale.category20b();
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	  	var thisColor = color(Math.floor((Math.random()*20)+1));
	  	context.fillStyle = thisColor;
	  	context.beginPath();
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    //context.moveTo(cx, cy);
	    context.arc(cx, cy, 3, 0, 2 * Math.PI, false);
	    context.stroke();
	    context.fill();
	  }
	}

	var start = performance.now();
	var color = d3.scale.category20b();
  var i = -1, n = data.length, d, cx, cy;
  while (++i < n) {
  	var thisColor = color(Math.floor((Math.random()*20)+1));
  }
	var end = performance.now();
	console.log("Time to generate " + numberOfElements + " random colors: " + (end-start) + " milliseconds.");


	function drawSquaresColors(context) {
		var color = d3.scale.category20b();
		var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	  	var thisColor = color(Math.floor((Math.random()*20)+1));
	  	context.fillStyle = thisColor;
	    d = data[i];
	    cx = Math.floor(d.x) + 0.5;
	    cy = Math.floor(d.y) + 0.5;
	    context.fillRect(cx, cy, 6, 6);
	    context.strokeRect(cx, cy, 6, 6);
	  }
	}

	function drawSquares(context) {
		var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = Math.floor(d.x) + 0.5;
	    cy = Math.floor(d.y) + 0.5;
	    context.fillRect(cx, cy, 6, 6);
	    context.strokeRect(cx, cy, 6, 6);
	  }
	}

	// Create a second "buffer" canvas but don't append it to the document
	var tmpCanvas = document.createElement('canvas');
	tmpCanvas.width = 16;
	tmpCanvas.height = 16;
	var tmpCtx = tmpCanvas.getContext('2d');
	tmpCtx.fillStyle = "blue";
	tmpCtx.strokeStyle = "black";
	tmpCtx.lineWidth = 1.5;
	tmpCtx.beginPath();
	tmpCtx.arc(4, 4, 3, 0, 2 * Math.PI, false);
	tmpCtx.stroke();
	tmpCtx.fill();

	var start = performance.now();
	drawCirclesOffscreen(circleOffscreenContext);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " image elements: " + (end-start) + " milliseconds.");

	function drawCirclesOffscreen(context) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    context.drawImage(tmpCanvas, cx, cy);
	  }
	}

	var stage = new Kinetic.Stage({
    container: 'container',
    width: width,
    height: height
  });

  var layer = new Kinetic.Layer();

  var start = performance.now();
	//drawCirclesKinetic(layer);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " Kinetic circle elements: " + (end-start) + " milliseconds.");

	function drawCirclesKinetic(layer) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    var circle = new Kinetic.Circle({
		    x: cx,
		    y: cy,
		    radius: 3.5,
		    fill: 'red',
		    stroke: 'black',
		    strokeWidth: 1
		  });
		  // add the shape to the layer
  		layer.add(circle);
	  }
	  // add the layer to the stage
  	stage.add(layer);
	}

	var tooltipLayer = new Kinetic.Layer();
  var dragLayer = new Kinetic.Layer();
  var tooltip = new Kinetic.Label({
    opacity: 0.75,
    visible: false,
    listening: false
  });
  tooltip.add(new Kinetic.Tag({
    fill: 'black',
    pointerDirection: 'down',
    pointerWidth: 10,
    pointerHeight: 10,
    lineJoin: 'round',
    shadowColor: 'black',
    shadowBlur: 10,
    shadowOffset: {x:10, y:10},
    shadowOpacity: 0.2
  }));

  tooltip.add(new Kinetic.Text({
    text: '',
    fontFamily: 'Calibri',
    fontSize: 18,
    padding: 5,
    fill: 'white'
  }));
  
  tooltipLayer.add(tooltip);

  stage.add(tooltipLayer);
  stage.add(dragLayer);

  stage.on('mouseover mousemove dragmove', function(evt) {
	  var node = evt.target;
	  if (node) {
	    // update tooltip
	    var mousePos = node.getStage().getPointerPosition();
	    tooltip.position({x:mousePos.x, y:mousePos.y - 5});
	    tooltip.getText().text("node: " + node.x() + ", color: " + node.fill());
	    tooltip.show();
	    tooltipLayer.batchDraw();
	  }
	}); 

	stage.on('mouseout', function(evt) {
	  tooltip.hide();
	  tooltipLayer.draw();
	});

	var startLayer;

	stage.on('mousedown', function(evt) {
	  var shape = evt.target;
	  if (shape) {
	    startLayer = shape.getLayer();
	    shape.moveTo(dragLayer);
	    startLayer.draw();
	    // manually trigger drag and drop
	    shape.startDrag();
	  }
	});

	stage.on('mouseup', function(evt) {
	  var shape = evt.target;
	  if (shape) {
	    shape.moveTo(startLayer);
	    dragLayer.draw();
	    startLayer.draw();
	  }
	});

  var stage2 = new Kinetic.Stage({
    container: 'container2',
    width: width,
    height: height
  });

  var layer2 = new Kinetic.Layer();

  var start = performance.now();
	//drawSquaresKinetic(layer2);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " Kinetic square elements: " + (end-start) + " milliseconds.");

	function drawSquaresKinetic(layer) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    var rect = new Kinetic.Rect({
        x: cx,
        y: cy,
        width: 6,
        height: 6,
        fill: 'green',
        stroke: 'black',
        strokeWidth: 1
      });
		  // add the shape to the layer
  		layer.add(rect);
	  }
	  // add the layer to the stage
  	stage2.add(layer);
	}
  
	var svg = d3.select("#svg").append("svg")
	    .attr("width", width)
	    .attr("height", height);

	var start = performance.now();
	var circle = svg.selectAll("circle")
	    .data(data)
	  .enter().append("circle")
	    .attr("cx", function(d){
	    	return d.x;
	    })
	    .attr("cy", function(d){
	    	return d.y;
	    })
	    .attr("r", 3.5)
	    .attr("fill", "yellow")
	    .attr("stroke", "black")
	    ;
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " svg elements: " + (end-start) + " milliseconds.");

	var svgColors = d3.select("#svg").append("svg")
	    .attr("width", width)
	    .attr("height", height);

	var start = performance.now();
	var color = d3.scale.category20b();
	var circleColors = svgColors.selectAll("circle")
	    .data(data)
	  .enter().append("circle")
	    .attr("cx", function(d){
	    	return d.x;
	    })
	    .attr("cy", function(d){
	    	return d.y;
	    })
	    .attr("r", 3.5)
	    .attr("fill", function(d){
	    	return color(Math.floor((Math.random()*20)+1));
	    })
	    .attr("stroke", "black")
	    ;
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " colored svg elements: " + (end-start) + " milliseconds.");


	var fabricCanvasElement = d3.select("#fabric").append("canvas")
	  .attr("width", width)
	  .attr("height", height)
	  .attr("id", "fabric1")
	  ;
	var fabricCanvas = new fabric.Canvas('fabric1', { renderOnAddRemove: false, stateful: false });

	function drawSquaresFabric(canvas) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    var rect = new fabric.Rect({
			  left: cx,
			  top: cy,
			  fill: 'pink',
			  width: 6,
			  height: 6,
			  hasBorders: false,
			  stroke : 'black',
        strokeWidth : 1
			});
		  // add the shape to the layer
  		canvas.add(rect);
	  }
	  canvas.renderAll();
	}

	var start = performance.now();
	//drawSquaresFabric(fabricCanvas);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " Fabric square elements: " + (end-start) + " milliseconds.");


	var fabricCanvasElement2 = d3.select("#fabric").append("canvas")
	  .attr("width", width)
	  .attr("height", height)
	  .attr("id", "fabric2")
	  ;
	var fabricCanvas2 = new fabric.Canvas('fabric2', { renderOnAddRemove: false, stateful: false });

	function drawCirclesFabric(canvas) {
	  var i = -1, n = data.length, d, cx, cy;
	  while (++i < n) {
	    d = data[i];
	    cx = d.x;
	    cy = d.y;
	    var circle = new fabric.Circle({
			  left: cx,
			  top: cy,
			  fill: 'brown',
			  radius: 4,
			  hasBorders: false,
			  stroke : 'black',
        strokeWidth : 1
			});
		  // add the shape to the layer
  		canvas.add(circle);
	  }
	  canvas.renderAll();
	}

	var start = performance.now();
	//drawCirclesFabric(fabricCanvas2);
	var end = performance.now();
	console.log("Time to render " + numberOfElements + " Fabric circle elements: " + (end-start) + " milliseconds.");



	var dataContainer = base.append("custom");

	function drawCustom(data) {
	  var scale = d3.scale.linear()
	    .range([10, 390])
	    .domain(d3.extent(data));
	  
	  var dataBinding = dataContainer.selectAll("custom.rect")
	    .data(data, function(d) { return d; });
	  
	  dataBinding
	    .attr("size", 15)
	    .attr("fillStyle", "green");
	  
	  dataBinding.enter()
	      .append("custom")
	      .classed("rect", true)
	      .attr("x", scale)
	      .attr("y", 100)
	      .attr("size", 8)
	      .attr("fillStyle", "red");
	  
	  dataBinding.exit()
	    .attr("size", 5)
	    .attr("fillStyle", "lightgrey");

	  drawCanvas();
	}

	function drawCanvas() {

	  // clear canvas
	  context.fillStyle = "#fff";
	  context.rect(0,0,chart.attr("width"),chart.attr("height"));
	  context.fill();
	  
	  var elements = dataContainer.selectAll("custom.rect");
	  elements.each(function(d) {
	    var node = d3.select(this);
	    
	    context.beginPath();
	    context.fillStyle = node.attr("fillStyle");
	    context.rect(node.attr("x"), node.attr("y"), node.attr("size"), node.attr("size"));
	    context.fill();
	    context.closePath();
	    
	  })
	}

	// drawCustom([1,2,13,20,23]);
	// drawCustom([1,2,12,16,20]);

	  

	}
	//]]&gt;  
	</script>
</head>
<body>
	<div id="vis"><h4>Native</h4></div>
	<div id="kinetic"><h4>Kinetic</h4>
		<div id="container" class="kinetic"></div><div id="container2" class="kinetic"></div>
	</div>
	<div id="fabric"><h4>Fabric</h4>
	</div>
	<div id="svg"><h4>SVG D3</h4></div>
</body>
</html>